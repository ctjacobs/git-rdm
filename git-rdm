#!/usr/bin/env python

#!/usr/bin/env python

import os, os.path, sys
import argparse
import git
import logging
import sqlite3 as sqlite

_LOG = logging.getLogger(__name__)
_HANDLER = logging.StreamHandler()
_LOG.addHandler(_HANDLER)
_HANDLER.setFormatter(logging.Formatter('%(module)s %(levelname)s: %(message)s'))
del(_HANDLER)
_LOG.setLevel(logging.INFO)

try:
    import pyrdm
    from pyrdm.publisher import Publisher
except ImportError:
    _LOG.exception("Could not import the PyRDM library necessary for research data management.")
    sys.exit(1)

PUBLICATIONS_TABLE = "publications"

class RDM:
    
    def __init__(self):
    
        # Open the Git repository.
        try:
            self.repo = git.Repo(".")
        except git.InvalidGitRepositoryError:
            _LOG.exception("Not in a Git version controlled repository.")
            sys.exit(1)

        return
        
    
    
    # git-rdm subcommands

    
    def initialise(self):
        """ Initialise the RDM control directory and set up the SQL database of published files. """
        
        # Create the RDM control directory if it doesn't already exist.
        if not os.path.exists(".rdm"):
            os.makedirs(".rdm")
        
        # Set up the SQLite database.
        self.db_connect()
        
        # If this file already exists, then skip this step.
        if self.db_exists():
            response = raw_input("The publications database already exists. Do you want to overwrite it? (y/n)\n")
            if response == "y":
                overwrite = True
                _LOG.info("Overwriting...")
                with self.connection:
                    c = self.connection.cursor()
                    query = "DROP TABLE %s" % PUBLICATIONS_TABLE
                    c.execute(query)
            else:
                overwrite = False
                _LOG.info("Not overwriting.")
                return

        # Set up publication table columns.
        with self.connection:
            c = self.connection.cursor()
            query = "CREATE TABLE %s (id INTEGER PRIMARY KEY AUTOINCREMENT, path TEXT, pid TEXT, doi TEXT)" % PUBLICATIONS_TABLE
            c.execute(query)

        # Disconnect.
        self.db_disconnect()

        return


    def add(self, path):
        """ Add a desired file to the 'publication' staging area. """
        
        self.db_connect()

        # Convert argument to a list of lists.
        if isinstance(path, str):
            paths = [os.path.abspath(path)]
        else:
            paths = path
            
        # Check that the file/files being added is/are actually under version control.
        for f in paths:
            found = False
            for b in self.repo.tree().blobs:
                if b.abspath == os.path.abspath(f):
                    found = True
                    break
            if not found:
                _LOG.error("Could not add file '%s' for publishing because it is not under Git version control." % f)
                return
        
        # Check that the file has not been added for publication already. If not, then add it to the database.
        for f in paths:
            with self.connection:
                query = "SELECT * FROM %s WHERE path=? AND doi is NULL" % PUBLICATIONS_TABLE
                c = self.connection.cursor()
                c.execute(query, [os.path.abspath(f)])
                result = c.fetchall()
                if len(result) > 0:
                    _LOG.warning("File '%s' has been added already. Skipping..." % os.path.abspath(f))
                else:
                    query = "INSERT INTO %s VALUES (NULL, ?, NULL, NULL)" % PUBLICATIONS_TABLE
                    c = self.connection.cursor()
                    c.execute(query, [os.path.abspath(f)])
            
        
        #query = "SELECT * FROM %s" % PUBLICATIONS_TABLE
        #with self.connection:
        #    c = self.connection.cursor()
        #    c.execute(query)
        #    print c.fetchone()
        self.db_disconnect()
        return

    def rm(self, path):
        """ Remove a desired file from the 'publication' staging area. """
        
        self.db_connect()
        
        if isinstance(path, str):
            paths = [[os.path.abspath(path)]]
        else:
            paths = [path]        
        
        query = "DELETE FROM %s WHERE path=?" % PUBLICATIONS_TABLE
        with self.connection:
            c = self.connection.cursor()
            c.executemany(query, paths)

        self.db_disconnect()
        
        return

    def ls(self):
        """ List all published files, and files to be published. """
        
        self.db_connect()   
          
        # List all published files.
        query = "SELECT * FROM %s WHERE doi IS NOT NULL" % PUBLICATIONS_TABLE
        with self.connection:
            c = self.connection.cursor()
            c.execute(query)
            result = c.fetchall()
            if len(result) > 0:
                _LOG.info("Published files:")
                for r in result:
                    _LOG.info("\t"+r["path"] + " (" + r["doi"] + ")")
                
        # List all files staged for publishing.
        query = "SELECT * FROM %s WHERE doi IS NULL" % PUBLICATIONS_TABLE
        with self.connection:
            c = self.connection.cursor()
            c.execute(query)
            result = c.fetchall()
            if len(result) > 0:
                _LOG.info("Files staged for publishing:")
                for r in result:
                    _LOG.info("\t"+r["path"])
                
        self.db_disconnect()
        
        return
        
    def publish(self, service, pid=None):
        """ Publish the desired files. """

        self.db_connect()

        # Find all files without a DOI (and assume these are in the publication staging area).
        with self.connection:
            query = "SELECT * FROM %s WHERE doi IS NULL" % PUBLICATIONS_TABLE
            c = self.connection.cursor()
            c.execute(query)
            to_publish = c.fetchall()

        if not to_publish:
            _LOG.warning("No files selected for publication.")
            return

        # Does the user needs to commit any modified files first?
        modified_files = self.repo.git.diff('HEAD~1..HEAD', name_only=True)
        overlap = False
        for f in to_publish:
            if f["path"] in modified_files:
                overlap = True
        if self.repo.is_dirty() and overlap:
            _LOG.error("Uncomitted changes exist in the repository. Please commit these changes before trying to publish any files.")
            return
        
        # Get the minimal amount of metadata needed to publish from the user.
        parameters = {}          
        
        # Publish to the repository hosting service.
        private = True #FIXME: Get the user to define this.
        self.publisher = Publisher(service=service)
        #pid, doi = self.publisher.publish_data(parameters, pid=pid, private=private)
        doi = "10.LOL.10/10.50figshare"
        pid = str(23423)
        
        # Update the publications database by adding the DOIs and publication IDs to the previously-staged files.
        with self.connection:
            c = self.connection.cursor()
            query = "UPDATE %s SET doi=? WHERE doi IS NULL" % (PUBLICATIONS_TABLE)
            c.execute(query, [doi])
            query = "UPDATE %s SET pid=? WHERE pid IS NULL" % (PUBLICATIONS_TABLE)
            c.execute(query, [pid])
          
        self.db_disconnect()
        
        return
        
        
        
    # Helpers

    def db_connect(self):
        _LOG.debug("Attempting to connect to publication database...")
        path = self.repo.working_dir + "/.rdm/publications.db"
        try:
            self.connection = sqlite.connect(path)
            self.connection.row_factory = sqlite.Row
            _LOG.debug("Connected successfully!")
        except sqlite.Error as e:
            _LOG.exception(e)
        return

    def db_disconnect(self):
        if(self.connection):
            self.connection.close()
        return

    def db_search_by_path(self, path):
        try:
            with self.connection:
                c = self.connection.cursor()
                query = "SELECT * FROM %s WHERE path=?" % PUBLICATIONS_TABLE
                c.execute(query, [path])
                return c.fetchone()  # This path is a unique absolute path.
        except sqlite.Error as e:
            logging.exception(e)
            return None
    
    def db_exists(self):
        """ Return True if the publications table exists in the database. """
        with self.connection:
            c = self.connection.cursor()
            c.execute("SELECT EXISTS(SELECT 1 FROM sqlite_master WHERE name=?)", [PUBLICATIONS_TABLE])
            exists = c.fetchone()
            if(exists[0] == 1):
                return True
            else:
                return False

    def status(self):
        print(self.repo.git.status())


if(__name__ == "__main__"):
    # Command line arguments
    parser = argparse.ArgumentParser(prog="git-rdm")
    parser.add_argument("-d", "--debug", action="store_true", default=False, help="Enable debugging.")
    
    # Subparsers
    subparsers = parser.add_subparsers(help="The subcommand of 'git rdm'.", dest='subcommand')
    
    # 'git rdm init'
    init_parser = subparsers.add_parser("init", help="Initialise the .rdm control directory and publication database.")
    
    # 'git rdm add'
    add_parser = subparsers.add_parser("add", help="Add a file to the publishing staging area.")
    add_parser.add_argument("path", help="The path to the file to be added.", action="store", type=str)

    # 'git rdm rm'
    rm_parser = subparsers.add_parser("rm", help="Remove a file from the publishing staging area.")
    rm_parser.add_argument("path", help="The path to the file to be removed.", action="store", type=str)

    # 'git rdm ls'
    ls_parser = subparsers.add_parser("ls", help="List the published files, and files staged for publishing.")
    
    # 'git rdm publish'
    publish_parser = subparsers.add_parser("publish", help="Publish the files in the publishing staging area.")
    publish_parser.add_argument("service", help="The service with which to publish.", action="store", type=str)
    
    # Parse all arguments
    args = parser.parse_args()

    # Output debugging messages to a file
    if(args.debug):
        # Get the root logger
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)

    # Execute the desired subcommand
    rdm = RDM()
    if args.subcommand == "init":
        rdm.initialise()
    elif args.subcommand == "add":
        rdm.add(args.path)
    elif args.subcommand == "rm":
        rdm.rm(args.path)
    elif args.subcommand == "publish":
        rdm.publish(args.service)
    elif args.subcommand == "status":
        rdm.status()
    elif args.subcommand == "ls":
        rdm.ls()
    else:
        _LOG.error("Unknown git-rdm subcommand '%s'" % args.subcommand)
        
