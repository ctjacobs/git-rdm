#!/usr/bin/env python

#!/usr/bin/env python

import os, os.path, sys
import argparse
import git
import logging
import sqlite3 as sqlite

_LOG = logging.getLogger(__name__)
_HANDLER = logging.StreamHandler()
_LOG.addHandler(_HANDLER)
_HANDLER.setFormatter(logging.Formatter('%(module)s %(levelname)s: %(message)s'))
del(_HANDLER)
_LOG.setLevel(logging.INFO)

try:
    import pyrdm
except ImportError:
    _LOG.exception("Could not import the PyRDM library necessary for research data management.")
    #sys.exit(1)

PUBLICATIONS_TABLE = "publications"

class RDM:
    
    def __init__(self):
    
        # Open the Git repository.
        try:
            self.repo = git.Repo(".")
        except git.InvalidGitRepositoryError:
            _LOG.exception("Not in a Git version controlled repository.")
            sys.exit(1)
        
        self.to_publish = []
        
        return
        
    
    
    # git-rdm subcommands

    
    def init(self):
        """ Initialise the RDM control directory and set up the SQL database of published files. """
        
        # Create the RDM control directory if it doesn't already exist.
        if not os.path.exists(".rdm"):
            os.makedirs(".rdm")
        
        # Set up the SQLite database.
        _LOG.debug("Attempting to connect to publication database...")
        path = self.repo.working_dir + "/.rdm/publications.db"
        try:
            self.connection = sqlite.connect(path)
            self.connection.row_factory = sqlite.Row
            _LOG.debug("Connected successfully!")
        except sqlite.Error as e:
            _LOG.exception(e)
        
        # If this file already exists, then skip this step.
        if self.db_exists():
            _LOG.error("Cannot initialise the publications database since it already exists.")
        else:
            # Set up publication table columns.
            with self.connection:
                c = self.connection.cursor()
                query = "CREATE TABLE %s (id INTEGER PRIMARY KEY AUTOINCREMENT, path TEXT, title TEXT, description TEXT, doi TEXT)" % PUBLICATIONS_TABLE
                c.execute(query)

        # Disconnect.
        if(self.connection):
            self.connection.close()

        return


    def add(self, path):
        """ Add a desired file to the 'publication' staging area. """
        
        if self.repo.is_dirty():
            _LOG.error("Uncomitted changes exist in the repository. Please commit these changes before trying to publish any files.")
            return
            
        self.to_publish.append(path)
        
        return

    def rm(self, path):
        """ Remove a desired file from the 'publication' staging area. """
        
        if path in self.to_publish:
            self.to_publish.remove(path)
        else:
            _LOG.warning("File does not exist in the list of files to be published. Skipping...")
        
        return

    def publish(self, service, pid=None):
        """ Publish the desired files. """
        
        if self.repo.is_dirty():
            _LOG.error("Uncomitted changes exist in the repository. Please commit these changes before trying to publish any files.")
            return
        
        # Get the minimal amount of metadata needed to publish from the user.
        parameters = {}          
        
        # Publish to the repository hosting service.
        private= True #FIXME: Get the user to define this.
        self.publisher = pyrdm.Publisher(service=service)
        self.publisher.publish_data(parameters, pid=pid, private=private)
        
        # Update the publications database.
        
        
        # Clear the list of files to publish.
        self.to_publish = []
        
        return
        
        
        
    # Helpers

    def db_search_by_path(self, path):
        try:
            with self.connection:
                c = self.connection.cursor()
                query = "SELECT * FROM %s WHERE path=?" % PUBLICATIONS_TABLE
                c.execute(query, [path])
                return c.fetchone()  # This path is a unique absolute path.
        except sqlite.Error as e:
            logging.exception(e)
            return None
    
    def db_exists(self):
        """ Return True if the publications table exists in the database. """
        with self.connection:
            c = self.connection.cursor()
            c.execute("SELECT EXISTS(SELECT 1 FROM sqlite_master WHERE name=?)", [PUBLICATIONS_TABLE])
            exists = c.fetchone()
            if(exists[0] == 1):
                return True
            else:
                return False

    def status(self):
        print(self.repo.git.status())


if(__name__ == "__main__"):
    # Command line arguments
    parser = argparse.ArgumentParser(prog="git-rdm")
    parser.add_argument("-d", "--debug", action="store_true", default=False, help="Enable debugging.")
    
    # Subparsers
    subparsers = parser.add_subparsers(help="The subcommand of 'git rdm'.", dest='subcommand')
    
    # 'git rdm init'
    init_parser = subparsers.add_parser("init", help="Initialise the .rdm control directory and publication database.")
    
    # 'git rdm add'
    add_parser = subparsers.add_parser("add", help="Add a file to the publishing staging area.")
    add_parser.add_argument("path", help="The path to the file to be added.", action="store", type=str)

    # 'git rdm rm'
    rm_parser = subparsers.add_parser("rm", help="Remove a file from the publishing staging area.")
    rm_parser.add_argument("path", help="The path to the file to be removed.", action="store", type=str)

    # 'git rdm publish'
    publish_parser = subparsers.add_parser("publish", help="Publish the files in the publishing staging area.")
    publish_parser.add_argument("service", help="The service with which to publish.", action="store", type=str)
    
    # Parse all arguments
    args = parser.parse_args()

    # Output debugging messages to a file
    if(args.debug):
        # Get the root logger
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)

    # Execute the desired subcommand
    rdm = RDM()
    if args.subcommand == "init":
        rdm.init()
    elif args.subcommand == "add":
        rdm.add(args.path)
    elif args.subcommand == "rm":
        rdm.rm(args.path)
    elif args.subcommand == "publish":
        rdm.publish(args.service)
    elif args.subcommand == "status":
        rdm.status()
    else:
        _LOG.error("Unknown git-rdm subcommand '%s'" % args.subcommand)
        
